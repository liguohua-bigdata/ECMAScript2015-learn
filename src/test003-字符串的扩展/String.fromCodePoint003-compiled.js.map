{"version":3,"sources":["String.fromCodePoint003.js"],"names":[],"mappings":";;AAAA;;;AAGA;;;;AAIA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI;;;;AAIA,MAAI,IAAI,OAAO,YAAP,CAAoB,OAApB,CAAR;AACA,UAAQ,IAAR,CAAa,CAAb,EANJ,CAMoB;AACnB;AACD;;;;AAIA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI,MAAI,KAAK,OAAO,aAAP,CAAqB,OAArB,CAAT;AACA,UAAQ,IAAR,CAAa,EAAb,EAFJ,CAEqB;;AAEjB;AACA,MAAI,KAAK,OAAO,aAAP,CAAqB,IAArB,EAA2B,OAA3B,EAAoC,IAApC,MAA8C,gBAAvD;AACA,UAAQ,IAAR,CAAa,EAAb,EANJ,CAMqB;AACpB;AACD","file":"String.fromCodePoint003-compiled.js","sourcesContent":["/**\n * Created by liguohua on 16/10/10.\n */\n/**\n *ES5提供String.fromCharCode方法，用于从码点返回对应字符，\n * 但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）\n */\nconsole.log(\"**************001\");\n{\n    /*\n     String.fromCharCode不能识别大于0xFFFF的码点，\n     所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\n     */\n    let r = String.fromCharCode(0x20BB7)\n    console.info(r);// \"ஷ\"\n}\n/**\n *ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。\n * 在作用上，正好与codePointAt方法相反。\n */\nconsole.log(\"**************002\");\n{\n    let r1 = String.fromCodePoint(0x20BB7)\n    console.info(r1);// \"𠮷\"\n\n    //如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\n    let r2 = String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'\n    console.info(r2);// true\n}\n/**\n *注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。\n */\n"]}