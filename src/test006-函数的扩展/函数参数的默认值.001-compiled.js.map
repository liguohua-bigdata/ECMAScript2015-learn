{"version":3,"sources":["函数参数的默认值.001.js"],"names":[],"mappings":"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","file":"函数参数的默认值.001-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/12.\n */\n/**\n *在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n */\nconsole.log(\"**************001\");\n{\n    function log(x, y) {\n        // 检查函数log的参数y有没有赋值，如果没有，则指定默认值为World\n        // y = y || 'World';\n        if (typeof y === 'undefined') {\n            y = 'World';\n        }\n        console.log(x, y);\n    }\n\n    log('Hello') // Hello World\n    log('Hello', 'China') // Hello China\n    log('Hello', '') // Hello World\n}\n/**\n *ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。\n * 首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；\n * 其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n */\nconsole.log(\"**************002\");\n{\n    function log(x, y = 'World') {\n        console.log(x, y);\n    }\n\n    log('Hello') // Hello World\n    log('Hello', 'China') // Hello China\n    log('Hello', '') // Hello\n}\n/**\n *参数变量是默认声明的，所以不能用let或const再次声明。\n */\n{\n    function foo(x = 5) {\n        //参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。\n        // let x = 1; // error\n        // const x = 2; // error\n    }\n}\n/**\n *参数默认值可以与解构赋值的默认值，结合起来使用。\n */\nconsole.log(\"**************003\");\n{\n    function foo({x, y = 5}) {\n        console.log(x, y);\n    }\n\n    foo({}) // undefined, 5\n    foo({x: 1}) // 1, 5\n    foo({x: 1, y: 2}) // 1, 2\n    // foo() // TypeError: Cannot read property 'x' of undefined\n}\n/**\n *另一个对象的解构赋值默认值的例子\n */\nconsole.log(\"**************004\");\n{\n    function fetch(url, {body = '', method = 'GET', headers = {}}) {\n        console.log(method);\n    }\n\n    fetch('http://example.com', {});// \"GET\"\n\n    //第二个参数这个整体没有默认值,是不能够省略的\n    //fetch('http://example.com')// 报错\n}\n/**\n *双重默认值,其实就是给第二个参数这个整体一个默认值\n */\nconsole.log(\"**************005\");\n\n{\n    function fetch(url, {method = 'GET'} = {}) {\n        console.log(method);\n    }\n\n    fetch('http://example.com')\n    // \"GET\"\n}\n/**\n *两种写法的区别\n * 写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；\n * 写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\n */console.log(\"**************006\");\n\n{\n    // 写法一\n    function m1({x = 0, y = 0} = {}) {\n        return [x, y];\n    }\n\n    // 写法二\n    function m2({x, y} = {x: 0, y: 0}) {\n        return [x, y];\n    }\n\n    // 函数没有参数的情况\n    console.info(m1()); // [0, 0]\n    console.info(m2()); // [0, 0]\n\n    // x和y都有值的情况\n\n    console.info(m1({x: 3, y: 8}));  // [3, 8]\n    console.info(m2({x: 3, y: 8}));  // [3, 8]\n\n    // x有值，y无值的情况\n    console.info(m1({x: 3})); // [3, 0]\n    console.info(m2({x: 3}));  // [3, undefined]\n\n    // x和y都无值的情况\n    console.info();\n    console.info(m1({})); // [0, 0];\n    console.info(m2({}));  // [undefined, undefined]\n\n    console.info(m1({z: 3})); // [0, 0]\n    console.info(m2({z: 3})); // [undefined, undefined]\n}\n/**\n *参数默认值的位置\n * 通常情况下，定义了默认值的参数，应该是函数的尾参数。\n * 因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n */\nconsole.log(\"**************007\");\n{\n    // 例一\n    function f(x = 1, y) {\n        console.info([x, y]);\n    }\n    f() // [1, undefined]\n    f(2) // [2, undefined])\n    //f(, 1) // 报错,不能省略\n    f(undefined, 1) // [1, 1]\n}\nconsole.log(\"**************008\");\n{\n    // 例二\n    function f(x, y = 5, z) {\n        console.info([x, y, z]);\n    }\n    f() // [undefined, 5, undefined]\n    f(1) // [1, 5, undefined]\n    // f(1, ,2) // 报错\n    f(1, undefined, 2) // [1, 5, 2]\n}\n/**\n *如果传入undefined，将触发该参数等于默认值，null则没有这个效果。\n */\nconsole.log(\"**************009\");\n{\n    function foo(x = 5, y = 6) {\n        console.log(x, y);\n    }\n    //x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。\n    foo(undefined, null)// 5 null\n}\n"]}