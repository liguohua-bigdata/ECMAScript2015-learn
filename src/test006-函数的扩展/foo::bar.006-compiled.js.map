{"version":3,"sources":["foo::bar.006.js"],"names":[],"mappings":"AAAA;;;AAGA","file":"foo::bar.006-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/12.\n */\n/**\n *\n ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n\n foo::bar;\n // 等同于\n bar.bind(foo);\n\n foo::bar(...arguments);\n // 等同于\n bar.apply(foo, arguments);\n\n const hasOwnProperty = Object.prototype.hasOwnProperty;\n function hasOwn(obj, key) {\n  return obj::hasOwnProperty(key);\n}\n 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。\n\n var method = obj::obj.foo;\n // 等同于\n var method = ::obj.foo;\n\n let log = ::console.log;\n // 等同于\n var log = console.log.bind(console);\n 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。\n\n // 例一\n import { map, takeWhile, forEach } from \"iterlib\";\n\n getPlayers()\n ::map(x => x.character())\n ::takeWhile(x => x.strength > 100)\n ::forEach(x => console.log(x));\n\n // 例二\n let { find, html } = jake;\n\n document.querySelectorAll(\"div.myClass\")\n ::find(\"p\")\n ::html(\"hahaha\");\n\n */"]}