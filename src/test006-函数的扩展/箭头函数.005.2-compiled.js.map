{"version":3,"sources":["箭头函数.005.2.js"],"names":[],"mappings":"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","file":"箭头函数.005.2-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/12.\n */\n\n/**\n *1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n * setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。\n * 如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。\n * 但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。\n */\n{\n    function foo() {\n        setTimeout(() => {\n            console.log('id:', this.id);\n        }, 100);\n    }\n\n    var id = 21;\n    foo.call({id: 42});\n    // id: 42\n}\n/**\n *箭头函数可以让this指向固定化\n */\n{\n    function Timer() {\n        this.s1 = 0;\n        this.s2 = 0;\n        // 箭头函数,this绑定定义时所在的作用域,Timer\n        setInterval(() => this.s1++, 1000);\n        // 普通函数,this绑定运行时所在的作用域,window\n        setInterval(function () {\n            this.s2++;\n        }, 1000);\n    }\n\n    var timer = new Timer();\n\n    setTimeout(() => console.log('s1: ', timer.s1), 3100);\n    setTimeout(() => console.log('s2: ', timer.s2), 3100);\n    // s1: 3\n    // s2: 0\n}\n/**\n *请问下面的代码之中有几个this？\n *只有一个this，就是函数foo的this\n */\nconsole.log(\"**************001\");\n{\n    function foo() {\n        return () => {\n            return () => {\n                return () => {\n                    console.log('id:', this.id);\n                };\n            };\n        };\n    }\n\n    var f = foo.call({id: 1});\n    var t1 = f.call({id: 2})()(); // id: 1\n    var t2 = f().call({id: 3})(); // id: 1\n    var t3 = f()().call({id: 4}); // id: 1\n}\n/**\n *this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。\n * 箭头函数内部的变量arguments，其实是函数foo的arguments变量\n */\nconsole.log(\"**************001\");\n{\n    function foo() {\n        setTimeout(() => {\n            console.log('args:', arguments);\n        }, 100);\n    }\n\n    foo(2, 4, 6, 8);// args: [2, 4, 6, 8]\n}\n/**\n *由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n */\nconsole.log(\"**************001\");\n{\n    (function () {\n        return [\n            (() => this.x).bind({x: 'inner'})()\n        ];\n    }).call({x: 'outer'});// ['outer']\n}\n/**\n *长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，\n * 在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。\n */\n\n\n/**\n 嵌套的箭头函数\n 箭头函数内部，还可以再使用箭头函数。\n */\n{\n    let insert = (value) => ({\n        into: (array) => ({\n            after: (afterValue) => {\n                array.splice(array.indexOf(afterValue) + 1, 0, value);\n                return array;\n            }\n        })\n    });\n\n    let r = insert(2).into([1, 3]).after(1);\n    console.info(r);//[1, 2, 3]\n}\n/**\n * 一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\n\n */\n{\n    const pipeline = (...funcs) =>\n        val => funcs.reduce((a, b) => b(a), val);\n\n    const plus1 = a => a + 1;\n    const mult2 = a => a * 2;\n    const addThenMult = pipeline(plus1, mult2);\n\n    let r = addThenMult(5);\n    console.info(r);// 12\n}\n/**\n * 箭头函数还有一个功能，就是可以很方便地改写λ演算。\n *\n // λ演算的写法\n fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))\n\n // ES6的写法\n var fix = f => (x => f(v => x(x)(v)))\n (x => f(v => x(x)(v)));\n */\n\n\n"]}