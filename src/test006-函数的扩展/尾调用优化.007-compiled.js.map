{"version":3,"sources":["尾调用优化.007.js"],"names":[],"mappings":"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","file":"尾调用优化.007-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/12.\n */\n\n/**\n *什么是尾调用\n * 指某个函数的最后一步是调用另一个函数\n */\n{\n    function g() {\n       return 'hello';\n    }\n    function f(x){\n        return g(x);//尾调用\n    }\n}\n/**\n *以下三种情况，都不属于尾调用\n */\n{\n    {\n        // 情况一,\n        function f(x){\n            let y = g(x);//调用后还有操作\n            return y;\n        }\n    }\n    {\n        // 情况二\n        function f(x){\n            return g(x) + 1;//调用后还有操作\n        }\n    }\n    {\n        // 情况三\n        {\n            function f(x){\n                g(x);\n            }\n        }\n        //等同于\n        {\n            function f(x){\n                g(x);\n                return undefined;//调用后还有操作\n            }\n        }\n    }\n}\n/**\n *尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n */\nconsole.log(\"**************001\");\n{\n    function m() {\n        return 'm';\n    }\n    function n() {\n        return 'n';\n    }\n    function f(x) {\n        if (x > 0) {\n            return m(x);//尾调用\n        }\n        return n(x);//尾调用\n    }\n}\n/**\n *尾调用\n * 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。\n * 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。\n * 如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，\n 只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n */\n{\n    {\n        function f() {\n            let m = 1;\n            let n = 2;\n            return g(m + n);\n        }\n        f();\n    }\n    // 等同于\n    {\n        function f() {\n            return g(3);\n        }\n        f();\n    }\n    // 等同于\n    {\n        // 等同于\n        g(3);\n    }\n    /**\n     * 如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。\n     * 但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。\n     * “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。\n     * 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n     */\n}\n/**\n *只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n */\n{\n    function addOne(a){\n        var one = 1;\n        function inner(b){\n            return b + one;\n        }\n        return inner(a);\n    }\n    /**\n     * 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。\n     */\n}\n\n\n\n/**\n *尾递归\n * 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。\n * 但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n */\n{\n    {\n        function factorial(n) {\n            if (n === 1) return 1;\n            return n * factorial(n - 1);\n        }\n        factorial(5) // 120\n        /**\n         * 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)\n         */\n    }\n    //如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n    {\n        function factorial(n, total) {\n            if (n === 1) return total;\n            return factorial(n - 1, n * total);\n        }\n        factorial(5, 1) // 120\n    }\n\n}\n/**\n *\n */\nconsole.log(\"**************001\");\n{\n    // 如果是非尾递归的fibonacci 递归方法\n    {\n        function Fibonacci (n) {\n            if ( n <= 1 ) {return 1};\n\n            return Fibonacci(n - 1) + Fibonacci(n - 2);\n        }\n        Fibonacci(10); // 89\n        // Fibonacci(100)\n        // Fibonacci(500)\n        // 堆栈溢出了\n    }\n    //如果我们使用尾递归优化过的fibonacci 递归算法\n    {\n        function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n            if( n <= 1 ) {return ac2};\n\n            return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n        }\n        Fibonacci2(100) // 573147844013817200000\n        Fibonacci2(1000) // 7.0330367711422765e+208\n        Fibonacci2(10000) // Infinity\n    }\n}\n/**\n *由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，\n * 所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n */\n\n/**\n *递归函数的改写\n 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n */\n\n/**\n *方法一是在尾递归函数之外，再提供一个正常形式的函数。\n */\nconsole.log(\"**************001\");\n{\n    function tailFactorial(n, total) {\n        if (n === 1) return total;\n        return tailFactorial(n - 1, n * total);\n    }\n\n    function factorial(n) {\n        return tailFactorial(n, 1);\n    }\n    factorial(5) // 120\n}\n/**\n *函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化\n */\n{\n    function currying(fn, n) {\n        return function (m) {\n            return fn.call(this, m, n);\n        };\n    }\n\n    function tailFactorial(n, total) {\n        if (n === 1) return total;\n        return tailFactorial(n - 1, n * total);\n    }\n\n    const factorial = currying(tailFactorial, 1);\n\n    factorial(5) // 120\n}\n/**\n *第二种方法就简单多了，就是采用ES6的函数默认值。\n */\n{\n    function factorial(n, total = 1) {\n        if (n === 1) return total;\n        return factorial(n - 1, n * total);\n    }\n\n    factorial(5) // 120\n}\n/**\n *严格模式\n ES6的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n func.arguments：返回调用时函数的参数。\n func.caller：返回调用当前函数的那个函数。\n */\n\n/**\n *采用“循环”换掉“递归”\n */\n\n"]}