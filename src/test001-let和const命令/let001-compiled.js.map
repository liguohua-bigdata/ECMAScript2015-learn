{"version":3,"sources":["let001.js"],"names":[],"mappings":";;AAAA;;;AAGA;;;AAGA,QAAQ,GAAR,CAAY,mDAAZ;AACA,SAAS,OAAT,GAAmB;AACf;AACA;AACI,YAAI,IAAI,EAAR,CADJ,CACe;AACX,YAAI,IAAI,CAAR,CAFJ,CAEc;AACb;;AAED;AACA,YAAQ,GAAR,CAAY,CAAZ,EARe,CAQA;AAClB;AACD;;AAEA;;;AAGA,QAAQ,IAAR,CAAa,mDAAb;AACA,SAAS,OAAT,GAAmB;AACf,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,EAApB,EAAwB,GAAxB,EAA6B;AACzB,gBAAQ,GAAR,CAAY,CAAZ,EADyB,CACV;AAClB;AACD;AACH;AACD;;AAEA;;;;AAIA,QAAQ,IAAR,CAAa,mDAAb;AACA,SAAS,OAAT,GAAmB;AACf,QAAI,IAAI,EAAR;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,EAApB,EAAwB,GAAxB,EAA6B;AACzB,UAAE,CAAF,IAAO,YAAY;AACf,oBAAQ,GAAR,CAAY,CAAZ;AACH,SAFD;AAGH;AACD,MAAE,CAAF,IAPe,CAOP;AACX;AACD;;AAGA;;;;AAIA,QAAQ,IAAR,CAAa,mDAAb;AACA,SAAS,OAAT,GAAmB;AACf,QAAI,IAAI,EAAR;;AADe,+BAEN,CAFM;AAGX,UAAE,CAAF,IAAO,YAAY;AACf,oBAAQ,GAAR,CAAY,CAAZ;AACH,SAFD;AAHW;;AAEf,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,EAApB,EAAwB,GAAxB,EAA6B;AAAA,cAApB,CAAoB;AAI5B;AACD,MAAE,CAAF,IAPe,CAOP;AACX;AACD;;AAGA;;;AAGA,QAAQ,IAAR,CAAa,mDAAb;AACA,SAAS,OAAT,GAAmB;AACf,YAAQ,GAAR,CAAY,GAAZ,EADe,CACG;AAClB;;AAEA,QAAI,MAAM,CAAV;AACA,QAAI,MAAM,CAAV;AACH;AACD;;AAGA;;;;;;;;AAQA,QAAQ,IAAR,CAAa,mDAAb;AACA,SAAS,OAAT,GAAmB;AACf,QAAI,MAAM,GAAV;;AAEA,QAAI,IAAJ,EAAU;AACN;AACA;AACA;AACA;AACA,YAAI,aAAJ,CALM,CAKG;AACT,gBAAQ,GAAR,CAAY,IAAZ,EANM,CAMY;AAClB,eAAM,GAAN;AACA,gBAAQ,GAAR,CAAY,IAAZ,EARM,CAQY;AACrB;AACJ;AACD;;AAGA;;;;AAIA,QAAQ,IAAR,CAAa,+CAAb;AACA,SAAS,GAAT,GAA2B;AAAA,QAAd,CAAc,uEAAV,CAAU;AAAA,QAAP,CAAO,uEAAH,CAAG;;AACvB,WAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACH;;AAED;;AAEA;;;AAGA,SAAS,IAAT,GAA4B;AAAA,QAAd,CAAc,uEAAV,CAAU;AAAA,QAAP,CAAO,uEAAH,CAAG;;AACxB,WAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACH;AACD,QAAQ,IAAR,CAAa,MAAb,E,CAAsB;;AAEtB","file":"let001-compiled.js","sourcesContent":["/**\n * Created by liguohua on 16/10/10.\n */\n/**\n * let命令所在的代码块内有效\n */\nconsole.log(\"******************************************test001\")\nfunction test001() {\n    //code block\n    {\n        let a = 10;//in block\n        var b = 1;//in function\n    }\n\n    // console.log(a);// ReferenceError: a is not defined.\n    console.log(b);//1\n}\ntest001();\n\n/**\n * for循环的计数器，就很合适使用let命令\n */\nconsole.info(\"******************************************test002\")\nfunction test002() {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);//ok\n    }\n    // console.log(i);//error\n}\ntest002();\n\n/**\n *使用var，最后输出的是10。\n * 变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。\n */\nconsole.info(\"******************************************test003\")\nfunction test003() {\n    var a = [];\n    for (var i = 0; i < 10; i++) {\n        a[i] = function () {\n            console.log(i);\n        };\n    }\n    a[6](); // 10\n}\ntest003();\n\n\n/**\n *如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。\n * 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。\n */\nconsole.info(\"******************************************test004\")\nfunction test004() {\n    var a = [];\n    for (let i = 0; i < 10; i++) {\n        a[i] = function () {\n            console.log(i);\n        };\n    }\n    a[6](); // 10\n}\ntest004();\n\n\n/**\n let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。\n */\nconsole.info(\"******************************************test005\")\nfunction test005() {\n    console.log(foo); // 输出undefined\n    // console.log(bar); // 报错ReferenceError\n\n    var foo = 2;\n    let bar = 2;\n}\ntest005();\n\n\n/**\n 暂时性死区\n 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响\n ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。\n 凡是在声明之前就使用这些变量，就会报错。\n 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。\n “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。\n */\nconsole.info(\"******************************************test006\")\nfunction test006() {\n    var tmp = 123;\n\n    if (true) {\n        // TDZ开始\n        // tmp = 'abc'; // ReferenceError\n        // console.log(tmp); // ReferenceError\n        // typeof tmp; // ReferenceError\n        let tmp; // TDZ结束\n        console.log(tmp); // undefined\n        tmp = 123;\n        console.log(tmp); // 123\n    }\n}\ntest006();\n\n\n/**\n 有些“死区”比较隐蔽，不太容易发现。\n ，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。\n */\nconsole.info(\"******************************************bar\")\nfunction bar(x = y, y = 2) {\n    return [x, y];\n}\n\n// bar(); // 报错\n\n/**\n *如果y的默认值是x，就不会报错，因为此时x已经声明了\n */\nfunction bar2(x = 2, y = x) {\n    return [x, y];\n}\nconsole.info(bar2()); // [2, 2]\n\n/**\n ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。\n 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，\n 只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n */"]}