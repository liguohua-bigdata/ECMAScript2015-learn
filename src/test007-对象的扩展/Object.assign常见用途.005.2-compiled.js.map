{"version":3,"sources":["Object.assign常见用途.005.2.js"],"names":[],"mappings":";;;;AAAA;;;AAGA;;;AAGA;AACI;AADJ,QAEU,KAFV,GAGQ,eAAY,CAAZ,EAAe,CAAf,EAAkB;AAAA;;AACd,eAAO,MAAP,CAAc,IAAd,EAAoB,EAAC,IAAD,EAAI,IAAJ,EAApB;AACH,KALT;;AAOI,QAAI,IAAI,IAAI,KAAJ,CAAU,UAAV,EAAsB,EAAtB,CAAR;AACA,YAAQ,IAAR,CAAa,CAAb;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;AAGA;AACI;AACA;AAAA,YACa,KADb,GACI,SAAS,KAAT,CAAe,MAAf,EAAuB;AACnB,mBAAO,OAAO,MAAP,CAAc,EAAd,EAAkB,MAAlB,CAAP;AACH,SAHL;AAIC;AACD;AACA;AAAA,YACa,MADb,GACI,SAAS,MAAT,CAAe,MAAf,EAAuB;AACnB,gBAAI,cAAc,OAAO,cAAP,CAAsB,MAAtB,CAAlB;AACA,mBAAO,OAAO,MAAP,CAAc,OAAO,MAAP,CAAc,WAAd,CAAd,EAA0C,MAA1C,CAAP;AACH,SAJL;AAKC;AACJ;AACD;;;AAGA;AACI;AACA;AACI,YAAM,QAAQ,SAAR,KAAQ,CAAC,MAAD;AAAA,8CAAY,OAAZ;AAAY,uBAAZ;AAAA;;AAAA,mBAAwB,OAAO,MAAP,gBAAc,MAAd,SAAyB,OAAzB,EAAxB;AAAA,SAAd;AACH;AACD;AACA;AACI,YAAM,SAAQ,SAAR,MAAQ;AAAA,+CAAI,OAAJ;AAAI,uBAAJ;AAAA;;AAAA,mBAAgB,OAAO,MAAP,gBAAc,EAAd,SAAqB,OAArB,EAAhB;AAAA,SAAd;AACH;AACJ;AACD;;;AAGA;AAAA;AAAA,YAMa,cANb,GAMI,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC7B,sBAAU,OAAO,MAAP,CAAc,EAAd,EAAkB,QAAlB,EAA4B,OAA5B,CAAV;AACH,SARL;;AAUI;;;;;;;;AATA,YAAM,WAAW;AACb,sBAAU,CADG;AAEb,0BAAc;AAFD,SAAjB;AADJ;AAgBC","file":"Object.assign常见用途.005.2-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *（1）为对象添加属性\n */\n{\n    //Object.assign方法，将x属性和y属性添加到Point类的对象实例\n    class Point {\n        constructor(x, y) {\n            Object.assign(this, {x, y});\n        }\n    }\n    let p = new Point('zhangsan', 18);\n    console.info(p);\n}\n/**\n *（2）为对象添加方法\n\n Object.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    ···\n  },\n  anotherMethod() {\n    ···\n  }\n});\n\n // 等同于下面的写法\n SomeClass.prototype.someMethod = function (arg1, arg2) {\n  ···\n};\n SomeClass.prototype.anotherMethod = function () {\n  ···\n};\n\n\n */\n\n/**\n *（3）克隆对象\n */\n{\n    //浅拷贝,只能克隆原始对象自身的值，不能克隆它继承的值\n    {\n        function clone(origin) {\n            return Object.assign({}, origin);\n        }\n    }\n    //如果想要保持继承链，可以采用下面的代码。\n    {\n        function clone(origin) {\n            let originProto = Object.getPrototypeOf(origin);\n            return Object.assign(Object.create(originProto), origin);\n        }\n    }\n}\n/**\n *（4）合并多个对象\n */\n{\n    //将多个对象合并到某个对象。\n    {\n        const merge = (target, ...sources) => Object.assign(target, ...sources);\n    }\n    //如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。\n    {\n        const merge = (...sources) => Object.assign({}, ...sources);\n    }\n}\n/**\n *（5）为属性指定默认值\n */\n{\n    const DEFAULTS = {\n        logLevel: 0,\n        outputFormat: 'html'\n    };\n\n    function processContent(options) {\n        options = Object.assign({}, DEFAULTS, options);\n    }\n\n    /**\n     * 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，\n     * 如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。\n     注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。\n     否则，将导致DEFAULTS对象的该属性不起作用。\n     */\n}\n"]}