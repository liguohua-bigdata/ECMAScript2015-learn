{"version":3,"sources":["Object.assign.005.001.js"],"names":[],"mappings":"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","file":"Object.assign.005.001-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n */\n{\n    var target = {a: 1};\n\n    var source1 = {b: 2};\n    var source2 = {c: 3};\n\n    Object.assign(target, source1, source2);\n    console.info(target)  // {a:1, b:2, c:3}\n}\n/**\n *如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n */\n{\n    var target = {a: 1, b: 1};\n\n    var source1 = {b: 2, c: 2};\n    var source2 = {c: 3};\n\n    Object.assign(target, source1, source2);\n    console.info(target) // {a:1, b:2, c:3}\n}\n/**\n *如果只有一个参数，Object.assign会直接返回该参数。\n */\n{\n    var obj = {a: 1};\n    let objo = Object.assign(obj)\n    let r = objo === obj;\n    console.info(r)// true\n\n}\n/**\n **如果只有一个参数，如果该参数不是对象，则会先转成对象，然后返回。\n * 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。\n */\n{\n    let r = typeof Object.assign(2)\n    console.info(r)// \"object\"\n    /**\n     由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。\n     Object.assign(undefined) // 报错\n     Object.assign(null) // 报错\n     */\n}\n/**\n *如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。\n * 首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。\n */\n{\n    let obj = {a: 1};\n    Object.assign(obj, undefined) === obj // true\n    Object.assign(obj, null) === obj // true\n}\n/**\n *其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\n */\n{\n    //字符串的包装对象，会产生可枚举属性。\n    var v1 = 'abc';\n    //数值和布尔值不会参数可枚举属性,都会被忽略。\n    var v2 = true;\n    var v3 = 10;\n\n    var obj = Object.assign({}, v1, v2, v3);\n    console.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n}\n\n/**\n *布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，\n * 这个属性是不会被Object.assign拷贝的。\n * 只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝\n */\n{\n    let r = Object(true);\n    console.log(r);// {[[PrimitiveValue]]: true}\n\n    Object(10);\n    console.log(r);//  {[[PrimitiveValue]]: 10}\n\n    Object('abc');\n    console.log(r);// {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"}\n}\n\n/**\n *Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。\n */\n{\n\n    //invisible，这个属性并没有被拷贝进去。\n    let r = Object.assign({b: 'c'},\n        Object.defineProperty(\n            {},\n            'invisible', {\n                enumerable: false,\n                value: 'hello'\n            })\n    )\n    console.info(r); // { b: 'c' }\n}\n/**\n *属性名为Symbol值的属性，也会被Object.assign拷贝\n */\n{\n    let r = Object.assign({a: 'b'}, {[Symbol('c')]: 'd'})\n    console.info(r);// { a: 'b', Symbol(c): 'd' }\n}\n/**\n *注意点 § ⇧\n Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\n */\n{\n    var obj1 = {a: {b: 1}};\n    var obj2 = Object.assign({}, obj1);\n\n    let r0 = obj1.a.b\n    console.info(r0);// 1\n\n    let r = obj2.a.b\n    console.info(r);// 1\n\n    obj1.a.b = 2;\n\n    r0 = obj1.a.b\n    console.info(r0);// 2\n\n    r = obj2.a.b\n    console.info(r);// 2\n}\n/**\n *这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。\n */\n{\n    var target = {a: {b: 'c', d: 'e'}}\n    var source = {a: {b: 'hello'}}\n    let r = Object.assign(target, source)\n    console.info(r);// { a: { b: 'hello' } }\n}\n/**\n *Object.assign可以用来处理数组，但是会把数组视为对象。\n */\n{\n   let r= Object.assign([1, 2, 3], [4, 5])\n    console.info(r);// [4, 5, 3]\n    /**\n     *    上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此目标数组的0号属性4覆盖了原数组的0号属性1。\n     */\n}\n"]}