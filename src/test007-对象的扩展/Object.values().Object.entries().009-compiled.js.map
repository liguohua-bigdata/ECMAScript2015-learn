{"version":3,"sources":["Object.values().Object.entries().009.js"],"names":[],"mappings":";;AAAA;;;AAGA;;;AAGA;AACI,MAAI,MAAM,EAAC,KAAK,KAAN,EAAa,KAAK,EAAlB,EAAV;AACA,MAAI,IAAI,OAAO,IAAP,CAAY,GAAZ,CAAR;AACA,UAAQ,IAAR,CAAa,CAAb,EAHJ,CAGoB;AACnB;AACD;;;AAGA,CAiBC;AAhBG;;;;;;;;;;;;;;AAiBJ;;;;AAIA,CA2CC;AA1CG;;;;;;AAMA;;;;;;;;AAQA;;;;;;AAMA;;;;;;AAOA;;;;;;AAOA;;;;;;;AASJ;;;;AAIA;;AAEI;;;;;;;AAOA;;;;;;AAMA;;;;;;;;;;AAUA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;AAoBH","file":"Object.values().Object.entries().009-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n */\n{\n    var obj = {foo: \"bar\", baz: 42};\n    let r = Object.keys(obj)\n    console.info(r);// [\"foo\", \"baz\"]\n}\n/**\n *目前，ES7有一个提案，引入了跟Object.keys配套的Object.values和Object.entries。\n */\n{\n    /*\n     let {keys, values, entries} = Object;\n     let obj = { a: 1, b: 2, c: 3 };\n\n     for (let key of keys(obj)) {\n     console.log(key); // 'a', 'b', 'c'\n     }\n\n     for (let value of values(obj)) {\n     console.log(value); // 1, 2, 3\n     }\n\n     for (let [key, value] of entries(obj)) {\n     console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n     }\n     */\n}\n/**\n *Object.values()\n Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\n */\n{\n    /*\n     var obj = { foo: \"bar\", baz: 42 };\n     Object.values(obj)\n     // [\"bar\", 42]\n     */\n\n    /*\n     返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。\n     var obj = { 100: 'a', 2: 'b', 7: 'c' };\n     Object.values(obj)\n     // [\"b\", \"c\", \"a\"]\n     上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。\n     */\n\n    /*\n     Object.values只返回对象自身的可遍历属性。\n     var obj = Object.create({}, {p: {value: 42}});\n     Object.values(obj) // []\n     */\n\n    /*\n     Object.values会过滤属性名为Symbol值的属性。\n     Object.values({ [Symbol()]: 123, foo: 'abc' });\n     // ['abc']\n     */\n\n\n    /*\n     如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。\n     Object.values('foo')\n     // ['f', 'o', 'o']\n     */\n\n\n    /*\n     如果参数不是对象，Object.values会先将其转为对象。\n     由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组\n     Object.values(42) // []\n     Object.values(true) // []\n     */\n\n\n}\n/**\n Object.entries § ⇧\n Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n */\n{\n\n    /*\n     var obj = { foo: 'bar', baz: 42 };\n     Object.entries(obj)\n     // [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n     除了返回值不一样，该方法的行为与Object.values基本一致。\n     */\n\n    /*\n     如果原对象的属性名是一个Symbol值，该属性会被省略。\n     Object.entries({ [Symbol()]: 123, foo: 'abc' });\n     // [ [ 'foo', 'abc' ] ]\n     */\n\n    /*\n     Object.entries的基本用途是遍历对象的属性。\n     let obj = { one: 1, two: 2 };\n     for (let [k, v] of Object.entries(obj)) {\n     console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`);\n     }\n     // \"one\": 1\n     // \"two\": 2\n     */\n\n    /*\n     Object.entries方法的一个用处是，将对象转为真正的Map结构。\n     var obj = { foo: 'bar', baz: 42 };\n     var map = new Map(Object.entries(obj));\n     map // Map { foo: \"bar\", baz: 42 }\n     */\n\n    /*\n     自己实现Object.entries方法，非常简单。\n\n     // Generator函数的版本\n     function* entries(obj) {\n     for (let key of Object.keys(obj)) {\n     yield [key, obj[key]];\n     }\n     }\n\n     // 非Generator函数的版本\n     function entries(obj) {\n     let arr = [];\n     for (let key of Object.keys(obj)) {\n     arr.push([key, obj[key]]);\n     }\n     return arr;\n     }\n     */\n\n}\n"]}