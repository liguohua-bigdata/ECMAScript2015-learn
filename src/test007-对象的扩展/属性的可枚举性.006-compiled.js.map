{"version":3,"sources":["属性的可枚举性.006.js"],"names":[],"mappings":";;;;;;AAAA;;;;AAIA;;;;AAIA;AACI,MAAI,MAAM,EAAC,KAAK,GAAN,EAAV;AACA,MAAI,IAAI,OAAO,wBAAP,CAAgC,GAAhC,EAAqC,KAArC,CAAR;AACA,UAAQ,IAAR,CAAa,CAAb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AASH;AACD;;;;;;AAMA;AACI,MAAI,KAAI,OAAO,wBAAP,CAAgC,OAAO,SAAvC,EAAkD,UAAlD,EAA8D,UAAtE;AACA,UAAQ,IAAR,CAAa,EAAb,EAFJ,CAEoB;;AAEhB,OAAI,OAAO,wBAAP,CAAgC,EAAhC,EAAoC,QAApC,EAA8C,UAAlD;AACA,UAAQ,IAAR,CAAa,EAAb,EALJ,CAKoB;;AAEhB,OAAI,OAAO,wBAAP,CAAgC;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,4BAC1B,CACL;AAF+B;;AAAA;AAAA,MAGlC,SAHE,EAGS,KAHT,EAGgB,UAHpB;AAIA,UAAQ,IAAR,CAAa,EAAb,EAXJ,CAWoB;AACnB;AACD","file":"属性的可枚举性.006-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n\n/**\n *对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。\n * Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。\n */\n{\n    let obj = {foo: 123};\n    let r = Object.getOwnPropertyDescriptor(obj, 'foo');\n    console.info(r);\n    //  {\n    //    value: 123,\n    //    writable: true,\n    //    enumerable: true,\n    //    configurable: true\n    //  }\n    /**\n     * ES5有三个操作会忽略enumerable为false的属性\n     for...in循环：只遍历对象自身的和继承的可枚举的属性\n     Object.keys()：返回对象自身的所有可枚举的属性的键名\n     JSON.stringify()：只串行化对象自身的可枚举的属性\n\n     ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\n\n     */\n}\n/**\n *\n 实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for...in操作。\n 比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for...in遍历到。\n ES6规定，所有Class的原型的方法都是不可枚举的。\n */\n{\n    let r = Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable;\n    console.info(r);// false\n\n    r = Object.getOwnPropertyDescriptor([], 'length').enumerable;\n    console.info(r);// false\n\n    r = Object.getOwnPropertyDescriptor(class {\n        foo() {\n        }\n    }.prototype, 'foo').enumerable;\n    console.info(r);// false\n}\n/**\n *总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。\n * 所以，尽量不要用for...in循环，而用Object.keys()代替。\n */\n"]}