{"version":3,"sources":["作为属性名的Symbol.002.js"],"names":[],"mappings":";;;;AAAA;;;AAGA;;;;AAIA;AACI,QAAI,WAAW,QAAf;;AAEA;AACA,QAAI,IAAI,EAAR;AACA,MAAE,QAAF,IAAc,QAAd;;AAEA;AACA,QAAI,wBACC,QADD,EACY,QADZ,CAAJ;;AAIA;AACA,QAAI,IAAI,EAAR;AACA,WAAO,cAAP,CAAsB,CAAtB,EAAyB,QAAzB,EAAmC,EAAE,OAAO,QAAT,EAAnC;;AAEA;AACA,MAAE,QAAF,EAjBJ,CAiBgB;AACf;AACD;;;;AAIA;AACI,QAAI,WAAW,QAAf;AACA,QAAI,IAAI,EAAR;;AAEA,MAAE,QAAF,GAAa,QAAb;AACA,MAAE,QAAF,EALJ,CAKgB;AACZ,MAAE,UAAF,EANJ,CAMkB;AACjB;AACD;;;AAGA;AACI;AACA;AACI,YAAI,IAAI,QAAR;AACA,YAAI,0BACC,CADD,EACK,UAAU,GAAV,EAAe,CAAI,CADxB,CAAJ;AAGA,YAAI,CAAJ,EAAO,GAAP;AACH;AACD;AACA;AAAA;AACI,gBAAI,IAAI,QAAR;AACA,gBAAI,0BACC,CADD,YACI,GADJ,EACS,CAAI,CADb,CAAJ;AAFJ;AAKC;AACJ;AACD;;;AAGA;AACI;AACA;AACI,YAAI,MAAJ,GAAa;AACT,mBAAO,OAAO,OAAP,CADE;AAET,kBAAM,OAAO,MAAP,CAFG;AAGT,kBAAM,OAAO,MAAP;AAHG,SAAb;AAKA,YAAI,IAAI,MAAJ,CAAW,KAAf,EAAsB,eAAtB;AACA,YAAI,IAAI,MAAJ,CAAW,IAAf,EAAqB,cAArB;AACH;AACD;AACA;AAAA;AAAA,gBAGa,aAHb,GAGI,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AAC1B,wBAAQ,KAAR;AACI,yBAAK,SAAL;AACI,+BAAO,WAAP;AACJ,yBAAK,WAAL;AACI,+BAAO,SAAP;AACJ;AACI,8BAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AANR;AAQH,aAZL;;AAcI;;;;;;AAbA,gBAAM,YAAe,QAArB;AACA,gBAAM,cAAe,QAArB;AAFJ;AAkBC;AACJ","file":"作为属性名的Symbol.002-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。\n * 这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n */\n{\n    var mySymbol = Symbol();\n\n    // 第一种写法\n    var a = {};\n    a[mySymbol] = 'Hello!';\n\n    // 第二种写法\n    var a = {\n        [mySymbol]: 'Hello!'\n    };\n\n    // 第三种写法\n    var a = {};\n    Object.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n    // 以上写法都得到同样结果\n    a[mySymbol] // \"Hello!\"\n}\n/**\n *Symbol值作为对象属性名时，不能用点运算符。\n * 因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。\n */\n{\n    var mySymbol = Symbol();\n    var a = {};\n\n    a.mySymbol = 'Hello!';\n    a[mySymbol] // undefined\n    a['mySymbol'] // \"Hello!\"\n}\n/**\n *同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。\n */\n{\n    //如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个Symbol值。\n    {\n        let s = Symbol();\n        let obj = {\n            [s]: function (arg) {  }\n        };\n        obj[s](123);\n    }\n    //采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。\n    {\n        let s = Symbol();\n        let obj = {\n            [s](arg) {  }\n        };\n    }\n}\n/**\n *Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n */\n{\n    //一个例子\n    {\n        log.levels = {\n            DEBUG: Symbol('debug'),\n            INFO: Symbol('info'),\n            WARN: Symbol('warn')\n        };\n        log(log.levels.DEBUG, 'debug message');\n        log(log.levels.INFO, 'info message');\n    }\n    //一个例子\n    {\n        const COLOR_RED    = Symbol();\n        const COLOR_GREEN  = Symbol();\n        function getComplement(color) {\n            switch (color) {\n                case COLOR_RED:\n                    return COLOR_GREEN;\n                case COLOR_GREEN:\n                    return COLOR_RED;\n                default:\n                    throw new Error('Undefined color');\n            }\n        }\n\n        /**\n         常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。\n         还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。\n         */\n    }\n}"]}