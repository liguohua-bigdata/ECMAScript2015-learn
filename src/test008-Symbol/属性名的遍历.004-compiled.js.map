{"version":3,"sources":["属性名的遍历.004.js"],"names":[],"mappings":";;;;;;;;AAAA;;;AAGA;;;;;;AAMA;AACI,QAAI,MAAM,EAAV;AACA,QAAI,IAAI,OAAO,GAAP,CAAR;AACA,QAAI,IAAI,OAAO,GAAP,CAAR;;AAEA,QAAI,CAAJ,IAAS,OAAT;AACA,QAAI,CAAJ,IAAS,OAAT;AACA;AACA,QAAI,gBAAgB,OAAO,qBAAP,CAA6B,GAA7B,CAApB;;AAEA,YAAQ,IAAR,CAAa,aAAb,EAVJ,CAU+B;AAC9B;AACD;;;AAGA;AACI,QAAI,MAAM,EAAV;;AAEA,QAAI,MAAM,OAAO,KAAP,CAAV;;AAEA,WAAO,cAAP,CAAsB,GAAtB,EAA2B,GAA3B,EAAgC;AAC5B,eAAO;AADqB,KAAhC;;AAIA,SAAK,IAAI,CAAT,IAAc,GAAd,EAAmB;AACf,gBAAQ,GAAR,CAAY,CAAZ,EADe,CACC;AACnB;AACD;AACA,QAAI,IAAI,OAAO,mBAAP,CAA2B,GAA3B,CAAR;AACA,YAAQ,IAAR,CAAa,CAAb,EAdJ,CAcmB;;AAEf,QAAI,OAAO,qBAAP,CAA6B,GAA7B,CAAJ;AACA,YAAQ,IAAR,CAAa,CAAb,EAjBJ,CAiBmB;AAClB;AACD;;;AAGA;AAAA;;AACI,QAAI,2CACC,OAAO,QAAP,CADD,EACoB,CADpB,kCAEM,CAFN,qCAGS,CAHT,SAAJ;;AAMA,QAAI,KAAI,QAAQ,OAAR,CAAgB,IAAhB,CAAR;AACA,YAAQ,IAAR,CAAa,EAAb,EARJ,CAQmB;AAClB;AACD;;;AAGA;AACI,QAAI,OAAO,OAAO,MAAP,CAAX;;AADJ,QAGU,UAHV;AAIQ,8BAAc;AAAA;;AACV,iBAAK,IAAL,IAAa,CAAb;AACH;;AANT;AAAA;AAAA,gCAQY,IARZ,EAQkB;AACN,qBAAK,KAAK,IAAL,CAAL,IAAmB,IAAnB;AACA,qBAAK,IAAL;AACH;AAXT;AAAA;AAAA,mCAasB,QAbtB,EAagC;AACpB,uBAAO,SAAS,IAAT,CAAP;AACH;AAfT;;AAAA;AAAA;;AAkBI,QAAI,IAAI,IAAI,UAAJ,EAAR;AACA,eAAW,MAAX,CAAkB,CAAlB,EAnBJ,CAmByB;;AAErB,MAAE,GAAF,CAAM,KAAN;AACA,eAAW,MAAX,CAAkB,CAAlB,EAtBJ,CAsByB;;AAErB;AACA,WAAO,IAAP,CAAY,CAAZ,EAzBJ,CAyBmB;AACf,WAAO,mBAAP,CAA2B,CAA3B,EA1BJ,CA0BkC;AAC9B,WAAO,qBAAP,CAA6B,CAA7B,EA3BJ,CA2BoC;AACnC","file":"属性名的遍历.004-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。\n * 但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。\n\n Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。\n */\n{\n    var obj = {};\n    var a = Symbol('a');\n    var b = Symbol('b');\n\n    obj[a] = 'Hello';\n    obj[b] = 'World';\n    //Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。\n    var objectSymbols = Object.getOwnPropertySymbols(obj);\n\n    console.info(objectSymbols)// [Symbol(a), Symbol(b)]\n}\n/**\n *另一个例子，Object.getOwnPropertySymbols方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。\n */\n{\n    var obj = {};\n\n    var foo = Symbol(\"foo\");\n\n    Object.defineProperty(obj, foo, {\n        value: \"foobar\",\n    });\n\n    for (var i in obj) {\n        console.log(i); // 无输出\n    }\n    //使用Object.getOwnPropertyNames方法得不到Symbol属性名\n    let r = Object.getOwnPropertyNames(obj)\n    console.info(r)// []\n\n    r = Object.getOwnPropertySymbols(obj)\n    console.info(r)// [Symbol(foo)]\n}\n/**\n *Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。\n */\n{\n    let obj = {\n        [Symbol('my_key')]: 1,\n        enum: 2,\n        nonEnum: 3\n    };\n\n    let r = Reflect.ownKeys(obj)\n    console.info(r)// [ 'enum', 'nonEnum', Symbol(my_key) ]\n}\n/**\n *由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n */\n{\n    var size = Symbol('size');\n\n    class Collection {\n        constructor() {\n            this[size] = 0;\n        }\n\n        add(item) {\n            this[this[size]] = item;\n            this[size]++;\n        }\n\n        static sizeOf(instance) {\n            return instance[size];\n        }\n    }\n\n    var x = new Collection();\n    Collection.sizeOf(x) // 0\n\n    x.add('foo');\n    Collection.sizeOf(x) // 1\n\n    //对象x的size属性是一个Symbol值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\n    Object.keys(x) // ['0']\n    Object.getOwnPropertyNames(x) // ['0']\n    Object.getOwnPropertySymbols(x) // [Symbol(size)]\n}\n\n"]}