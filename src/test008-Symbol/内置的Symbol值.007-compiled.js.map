{"version":3,"sources":["内置的Symbol值.007.js"],"names":[],"mappings":"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","file":"内置的Symbol值.007-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。\n */\n/**\n * Symbol.hasInstance\n 对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。\n 比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。\n */\n\n{\n    /*   class MyClass {\n     constructor(){\n\n     }\n     [Symbol.hasInstance](foo) {\n     console.info(foo);\n     return foo instanceof Array;\n     }\n     }\n     let myClass = new MyClass();\n     let r = [1, 2, 3] instanceof myClass;\n     console.info(r);// true*/\n    /**\n     * MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，\n     * 会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。\n     */\n}\n{\n    class Even {\n        static [Symbol.hasInstance](obj) {\n            return Number(obj) % 2 === 0;\n        }\n    }\n\n    let r = 1 instanceof Even;\n    console.info(r);// false\n    2 instanceof Even;\n    console.info(r);// true\n    12345 instanceof Even;\n    console.info(r);// false\n}\n/**\n *Symbol.isConcatSpreadable\n * 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。\n * 数组的默认行为是可以展开。Symbol.isConcatSpreadable属性等于true或undefined，都有这个效果。\n */\n{\n    //undefined\n    let arr1 = ['c', 'd'];\n    ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']\n    let r = arr1[Symbol.isConcatSpreadable]\n    console.info(r);// undefined\n\n\n    //不可展开\n    let arr2 = ['c', 'd'];\n    arr2[Symbol.isConcatSpreadable] = false;\n    r = ['a', 'b'].concat(arr2, 'e')\n    console.info(r);// ['a', 'b', ['c','d'], 'e']\n\n    //可展开\n    arr2[Symbol.isConcatSpreadable] = true;\n    r = ['a', 'b'].concat(arr2, 'e')\n    console.info(r);// ['a', 'b', ['c','d'], 'e']\n}\n\n\n/**\n 类似数组的对象也可以展开，但它的Symbol.isConcatSpreadable属性默认为false，必须手动打开。\n */\n{\n    //不可展开\n    let obj = {length: 2, 0: 'c', 1: 'd'};\n    let r = ['a', 'b'].concat(obj, 'e');\n    console.info(r);// ['a', 'b', obj, 'e']\n\n    //可展开\n    obj[Symbol.isConcatSpreadable] = true;\n    r = ['a', 'b'].concat(obj, 'e');\n    console.info(r);// ['a', 'b', 'c', 'd', 'e']\n}\n/**\n *对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性。\n */\n{\n    class A1 extends Array {\n        constructor(args) {\n            super(args);\n            //可展开\n            this[Symbol.isConcatSpreadable] = true;\n        }\n    }\n    class A2 extends Array {\n        constructor(args) {\n            super(args);\n            //不可展开\n            this[Symbol.isConcatSpreadable] = false;\n        }\n    }\n    let a1 = new A1();\n    a1[0] = 3;\n    a1[1] = 4;\n    let a2 = new A2();\n    a2[0] = 5;\n    a2[1] = 6;\n    let r = [1, 2].concat(a1).concat(a2)\n    console.info(r);// [1, 2, 3, 4, [5, 6]]\n}\n\n/**\n * Symbol.species\n * 对象的Symbol.species属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。\n * 即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。\n */\n{\n    class Student {\n        static get [Symbol.species]() {\n            console.info(\"here is call!\");\n            return this;\n        }\n    }\n    let r = new Student();\n    console.info(r);\n}\n\n\n/**\n *对象的Symbol.match属性，指向一个函数。\n * 当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。\n */\n{\n    //String.prototype.match(regexp)\n    // 等同于\n    //regexp[Symbol.match](this)\n\n    class MyMatcher {\n        [Symbol.match](string) {\n            return 'hello world'.indexOf(string);\n        }\n    }\n\n    'e'.match(new MyMatcher()) // 1\n}\n\n/**\n *Symbol.replace\n * 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\n */\n{\n    //String.prototype.replace(searchValue, replaceValue)\n    // 等同于\n    // searchValue[Symbol.replace](this, replaceValue)\n}\n\n/**\n *Symbol.search\n 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\n String.prototype.search(regexp)\n // 等同于\n regexp[Symbol.search](this)\n\n */\n{\n    class MySearch {\n        constructor(value) {\n            this.value = value;\n        }\n\n        [Symbol.search](string) {\n            return string.indexOf(this.value);\n        }\n    }\n    let r = 'foobar'.search(new MySearch('foo'));\n    console.info(r);// 0\n}\n\n/**\n *Symbol.split\n * 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\n String.prototype.split(separator, limit)\n // 等同于\n separator[Symbol.split](this, limit)\n */\n\n/**\n *Symbol.iterator\n 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n */\n{\n    var myIterable = {};\n    myIterable[Symbol.iterator] = function*() {\n        yield 1;\n        yield 2;\n        yield 3;\n    };\n\n    let r = [...myIterable];\n    console.info(r);// [1, 2, 3]\n    /**\n     * 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器\n     */\n    {\n        class Collection {\n            *[Symbol.iterator]() {\n                let i = 0;\n                while (this[i] !== undefined) {\n                    yield this[i];\n                    ++i;\n                }\n            }\n        }\n\n        let myCollection = new Collection();\n        myCollection[0] = 1;\n        myCollection[1] = 2;\n\n        for (let value of myCollection) {\n            console.log(value);\n        }\n        // 1\n        // 2\n    }\n}\n\n/**\n *Symbol.toPrimitive\n 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\n Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\n Number：该场合需要转成数值\n String：该场合需要转成字符串\n Default：该场合可以转成数值，也可以转成字符串\n */\n{\n    let obj = {\n        [Symbol.toPrimitive](hint) {\n            switch (hint) {\n                case 'number':\n                    return 123;\n                case 'string':\n                    return 'str';\n                case 'default':\n                    return 'default';\n                default:\n                    throw new Error();\n            }\n        }\n    };\n\n    let r = 2 * obj;\n    console.info(r);// 246\n\n    r = 3 + obj;\n    console.info(r);// '3default'\n\n    r = obj == 'default';\n    console.info(r);// true\n\n    r = String(obj);\n    console.info(r);// 'str'\n}\n\n\n/**\n *Symbol.toStringTag\n 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，\n 如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。\n 也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。\n */\n{\n    class Collection {\n        get [Symbol.toStringTag]() {\n            return 'xxxheool';\n        }\n    }\n    var x = new Collection();\n    let r = Object.prototype.toString.call(x);\n    console.info(r);// \"[object xxx]\"\n\n    /**\n     ES6新增内置对象的Symbol.toStringTag属性值如下。\n\n     JSON[Symbol.toStringTag]：'JSON'\n     Math[Symbol.toStringTag]：'Math'\n     Module对象M[Symbol.toStringTag]：'Module'\n     ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'\n     DataView.prototype[Symbol.toStringTag]：'DataView'\n     Map.prototype[Symbol.toStringTag]：'Map'\n     Promise.prototype[Symbol.toStringTag]：'Promise'\n     Set.prototype[Symbol.toStringTag]：'Set'\n     %TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等\n     WeakMap.prototype[Symbol.toStringTag]：'WeakMap'\n     WeakSet.prototype[Symbol.toStringTag]：'WeakSet'\n     %MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'\n     %SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'\n     %StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'\n     Symbol.prototype[Symbol.toStringTag]：'Symbol'\n     Generator.prototype[Symbol.toStringTag]：'Generator'\n     GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'\n     */\n}\n/**\n *Symbol.unscopables\n 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\n */\n{\n    let r = Array.prototype[Symbol.unscopables];\n    console.info(r);\n    // {\n    //   copyWithin: true,\n    //   entries: true,\n    //   fill: true,\n    //   find: true,\n    //   findIndex: true,\n    //   keys: true\n    // }\n\n    r = Object.keys(Array.prototype[Symbol.unscopables]);\n    console.info(r);\n    // ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'keys']\n\n    /**\n     上面代码说明，数组有6个属性，会被with命令排除。\n     */\n}\n/**\n *\n */\n{\n// 没有unscopables时\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n/**\n *\n */\n{\n\n}\n"]}