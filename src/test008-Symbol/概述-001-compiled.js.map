{"version":3,"sources":["概述-001.js"],"names":[],"mappings":";;;;AAAA;;;AAGA;;;;;;;AAOA;;;;;;AAMA;AACI,MAAI,IAAI,QAAR;AACA,MAAI,WAAW,CAAX,yCAAW,CAAX,CAAJ;AACA,UAAQ,IAAR,CAAa,CAAb,EAHJ,CAGoB;AACnB;AACD;;;;AAIA,CAEC;AACD;;;AAGA;AACI;AACA,MAAI,KAAK,OAAO,KAAP,CAAT;AACA,MAAI,KAAK,OAAO,KAAP,CAAT;AACA,UAAQ,IAAR,CAAa,EAAb,EAJJ,CAIoB;AAChB,UAAQ,IAAR,CAAa,EAAb,EALJ,CAKqB;AACjB,UAAQ,IAAR,CAAa,GAAG,QAAH,EAAb,EANJ,CAMgC;AAC5B,UAAQ,IAAR,CAAa,GAAG,QAAH,EAAb,EAPJ,CAO+B;AAC9B;AACD;;;AAGA;;AAEI;AACA;AACA,MAAI,KAAK,QAAT;AACA,MAAI,KAAK,QAAT;AACA,UAAQ,IAAR,CAAa,EAAb;AACA,UAAQ,IAAR,CAAa,EAAb;AACA,SAAO,EAAP,CARJ,CAQc;;AAEV;AACA,MAAI,KAAK,OAAO,KAAP,CAAT;AACA,MAAI,KAAK,OAAO,KAAP,CAAT;AACA,UAAQ,IAAR,CAAa,EAAb;AACA,UAAQ,IAAR,CAAa,EAAb;AACA,SAAO,EAAP,CAfJ,CAec;AACb;AACD;;;AAGA,CAQC;AAPG;;;;;;;;AAQJ;;;AAGA;AACI,MAAI,MAAM,OAAO,WAAP,CAAV;AACA,SAAO,GAAP,EAFJ,CAEgB;AACZ,MAAI,QAAJ,GAHJ,CAGmB;AAClB;AACD;;;AAGA;AACI,MAAI,MAAM,QAAV;AACA,UAAQ,GAAR,EAFJ,CAEiB;AACb,GAAC,GAAD,CAHJ,CAGU;;AAEN,MAAI,GAAJ,EAAS,CAER;AADG;;;AAGJ;;;;AAIH","file":"概述-001-compiled.js","sourcesContent":["/**\n * Created by liguohua on 2016/10/14.\n */\n/**\n *如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。\n\n ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，\n 前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n */\n\n/**\n * Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型\n * ，一种是原来就有的字符串，\n * 另一种就是新增的Symbol类型。\n * 凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n */\n{\n    let s = Symbol();\n    let r = typeof s;\n    console.info(r);// \"symbol\"\n}\n/**\n *Symbol函数前不能使用new命令，否则会报错。\n * 也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\n */\n{\n\n}\n/**\n *Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n */\n{\n    //如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n    var s1 = Symbol('foo');\n    var s2 = Symbol('bar');\n    console.info(s1)// Symbol(foo)\n    console.info(s2) // Symbol(bar)\n    console.info(s1.toString()) // \"Symbol(foo)\"\n    console.info(s2.toString())// \"Symbol(bar)\"\n}\n/**\n *Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。\n */\n{\n\n    //s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。\n    // 没有参数的情况\n    var s1 = Symbol();\n    var s2 = Symbol();\n    console.info(s1);\n    console.info(s2);\n    s1 === s2 // false\n\n    // 有参数的情况\n    var s1 = Symbol(\"foo\");\n    var s2 = Symbol(\"foo\");\n    console.info(s1);\n    console.info(s2);\n    s1 === s2 // false\n}\n/**\n *Symbol值不能与其他类型的值进行运算，会报错。\n */\n{\n    /*\n     var sym = Symbol('My symbol');\n     \"your symbol is \" + sym\n     // TypeError: can't convert symbol to string\n     `your symbol is ${sym}`\n     // TypeError: can't convert symbol to string\n     */\n}\n/**\n *Symbol值可以显式转为字符串。\n */\n{\n    var sym = Symbol('My symbol');\n    String(sym) // 'Symbol(My symbol)'\n    sym.toString() // 'Symbol(My symbol)'\n}\n/**\n *Symbol值也可以转为布尔值，但是不能转为数值。\n */\n{\n    var sym = Symbol();\n    Boolean(sym) // true\n    !sym  // false\n\n    if (sym) {\n        // ...\n    }\n\n    /*\n     Number(sym) // TypeError\n     sym + 2 // TypeError\n     */\n}\n\n"]}