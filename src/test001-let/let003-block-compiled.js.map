{"version":3,"sources":["let003-block.js"],"names":[],"mappings":";;AAAA;;;AAGA;;;;;AAKA;;;;AAIA,QAAQ,GAAR,CAAY,uBAAZ;AACA,IAAI,MAAM,IAAI,IAAJ,EAAV;AACA,SAAS,CAAT,GAAa;AACT,YAAQ,GAAR,CAAY,GAAZ;AACA,QAAI,KAAJ,EAAW;AACP;AACA,YAAI,MAAM,aAAV,CAFO,CAEiB;AAC3B;AACJ;AACD,I,CAAK;;;AAGL;;;AAGA,QAAQ,GAAR,CAAY,6BAAZ;AACA,SAAS,OAAT,GAAmB;AACf,QAAI,IAAI,OAAR;AACA;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,EAAE,MAAtB,EAA8B,GAA9B,EAAmC;AAC/B,gBAAQ,GAAR,CAAY,EAAE,CAAF,CAAZ;AACH;AACD;AACA,YAAQ,GAAR,CAAY,CAAZ,EAPe,CAOC;AAEnB;AACD;;AAGA;;;;;AAKA,QAAQ,GAAR,CAAY,wBAAZ;AACA,SAAS,EAAT,GAAc;AACV,QAAI,IAAI,CAAR;AACA,QAAI,IAAJ,EAAU;AACN,YAAI,KAAI,EAAR;AACH;AACD,YAAQ,GAAR,CAAY,CAAZ,EALU,CAKM;AACnB;AACD;;AAIA;;;AAGA,QAAQ,GAAR,CAAY,6BAAZ;AACA,SAAS,OAAT,GAAmB;AACf;AAAC;AAAC;AAAC;AACC;AACI,4BAAI,SAAS,aAAb;AACA,gCAAQ,GAAR,CAAY,MAAZ;AAEH;AACD;AACH;AAAC;AAAC;AAAC;AAEP;AACD;;AAEA;;;AAGA,QAAQ,GAAR,CAAY,6BAAZ;AACA,SAAS,OAAT,GAAmB;AACf;AAAC;AAAC;AAAC;AACC,wBAAI,SAAS,eAAb;AACA,4BAAQ,GAAR,CAAY,MAAZ;AACA;AACI,4BAAI,UAAS,eAAb;AACA,gCAAQ,GAAR,CAAY,OAAZ;AAEH;AACJ;AAAC;AAAC;AAAC;AAEP;AACD;;AAGA;;;;AAKA;;;AAGA,SAAS,EAAT,GAAc;AAAE,YAAQ,GAAR,CAAY,eAAZ;AAA+B;AAC9C,aAAY;AACT,QAAI,IAAJ,EAAU;AACN;AADM,YAEG,EAFH,GAEN,SAAS,EAAT,GAAc;AAAE,oBAAQ,GAAR,CAAY,cAAZ;AAA8B,SAFxC;;AAGN;AACH;AACD;AACH,CAPA,GAAD","file":"let003-block-compiled.js","sourcesContent":["/**\n * Created by liguohua on 16/10/10.\n */\n/**\n * 为什么需要块级作用域？\n ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n\n */\n/**\n *\n 第一种场景，内层变量可能会覆盖外层变量。\n */\nconsole.log(\"********************f\");\nvar tmp = new Date();\nfunction f() {\n    console.log(tmp);\n    if (false) {\n        //原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量\n        var tmp = \"hello world\";//覆盖外层变量,不论ture或false,都会覆盖外层变变量\n    }\n}\nf(); // undefined\n\n\n/**\n * 第二种场景，用来计数的循环变量泄露为全局变量\n */\nconsole.log(\"********************test001\");\nfunction test001() {\n    var s = 'hello';\n    //变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\n    for (var i = 0; i < s.length; i++) {\n        console.log(s[i]);\n    }\n    //循环变量泄露\n    console.log(i); // 5\n    \n}\ntest001();\n\n\n/**\n *let实际上为JavaScript新增了块级作用域\n * 函数有两个代码块，都声明了变量n，运行后输出5。\n * 这表示外层代码块不受内层代码块的影响\n */\nconsole.log(\"********************f1\");\nfunction f1() {\n    let n = 5;\n    if (true) {\n        let n = 10;\n    }\n    console.log(n); // 5\n}\nf1();\n\n\n\n/**\n * ES6允许块级作用域的任意嵌套\n */\nconsole.log(\"********************test002\");\nfunction test002() {\n    {{{{\n        {\n            let insane = 'Hello World'\n            console.log(insane);\n\n        }\n        // console.log(insane); // 报错\n    }}}};\n\n}\ntest002();\n\n/**\n * 内层作用域可以定义外层作用域的同名变量\n */\nconsole.log(\"********************test003\");\nfunction test003() {\n    {{{{\n        let insane = 'Hello World w';\n        console.log(insane);\n        {\n            let insane = 'Hello World n';\n            console.log(insane);\n\n        }\n    }}}};\n\n}\ntest003();\n\n\n/**\n * 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。\n */\n\n\n/**\n * 应该避免在块级作用域内声明函数\n */\nfunction f2() { console.log('I am outside!'); }\n(function () {\n    if (true) {\n        // 重复声明一次函数f2\n        function f2() { console.log('I am inside!'); }\n        f2();\n    }\n    // f2();//error\n}());"]}