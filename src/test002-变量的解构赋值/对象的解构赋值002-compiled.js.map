{"version":3,"sources":["对象的解构赋值002.js"],"names":[],"mappings":";;;;;;AAAA;;;AAGA;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,mBACqB,EAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,EADrB;AAAA,QACS,GADT,YACS,GADT;AAAA,QACc,GADd,YACc,GADd;;AAEI,YAAQ,GAAR,CAAY,GAAZ;AACA,YAAQ,GAAR,CAAY,GAAZ;AACH;;AAGD;;;;AAIA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,oBACgB,EAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,EADhB;AAAA,QACS,GADT,aACS,GADT;;AAEI,YAAQ,IAAR,CAAa,GAAb;AACH;;AAGD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,oBACqB,EAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,EADrB;AAAA,QACc,GADd,aACS,GADT;;AAEI,YAAQ,IAAR,CAAa,GAAb,EAFJ,CAEuB;AACtB;;AAGD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,oBAC+B,EAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,EAD/B;AAAA,QACc,GADd,aACS,GADT;AAAA,QACwB,GADxB,aACmB,GADnB;;AAEI,YAAQ,IAAR,CAAa,GAAb,EAFJ,CAEuB;AAEtB;AACD;;;;AAIA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,oBACqB,EAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,EADrB;AAAA,QACc,GADd,aACS,GADT;;AAEI,YAAQ,IAAR,CAAa,GAAb,EAFJ,CAEuB;AACnB,YAAQ,IAAR,CAAa,GAAb,EAHJ,CAGuB;AACtB;AACD;;;;;;AAMA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI,QAAI,aAAJ;AACA;AACA;AACA;AACA;AACH;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA;;AACI,QAAI,cAAJ;AAEI,aAAQ,EAAC,KAAK,CAAN,EAAR,EAAC,KAAD,SAAC,GAAD,UACI,QAAQ,IAAR,CAAa,KAAb,CADJ,CACqB;AAFzB,KAFJ,CAKO;AACH,YAAQ,IAAR,CAAa,KAAb,EANJ,CAMqB;;AAEjB,QAAI,aAAJ;AAEI,YAAa,EAAC,KAAK,CAAN,EAAb,EAAM,IAAN,QAAC,GAAD,SACI,QAAQ,IAAR,CAAa,IAAb,CADJ,CACqB;AAFzB,KATJ,CAYO;AACH,YAAQ,IAAR,CAAa,IAAb,EAbJ,CAaqB;AAEpB;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI,QAAI,MAAM;AACN,WAAG,CACC,OADD,EAEC,EAAC,GAAG,OAAJ,EAFD;AADG,KAAV;AAMA;;AAPJ,gCAQwB,GARxB,CAQS,CART;;AAAA,QAQa,CARb;AAAA,QAQiB,CARjB,aAQiB,CARjB;;AASI,YAAQ,IAAR,CAAa,CAAb,EATJ,CASoB;AAChB,YAAQ,IAAR,CAAa,CAAb,EAVJ,CAUoB;AACnB;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI,QAAI,OAAO;AACP,aAAK;AACD,mBAAO;AACH,sBAAM,CADH;AAEH,wBAAQ;AAFL;AADN;AADE,KAAX;;AADJ,QAUuB,IAVvB,GAUiC,IAVjC,CAUS,GAVT,CAUe,KAVf,CAUuB,IAVvB;;AAWI,YAAQ,IAAR,CAAa,IAAb,EAXJ,CAWuB;AACnB;AACA;AACH;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI,QAAI,OAAM,EAAV;AACA,QAAI,OAAM,EAAV;;AAFJ,oBAUQ;AACI,aAAK,GADT;AAEI,aAAK;AAFT,KAVR;AAMiB,SAAI,IANrB,aAMY,GANZ;AAOiB,SAAI,CAAJ,CAPjB,aAOY,GAPZ;;;AAgBI,YAAQ,IAAR,CAAa,IAAb,EAhBJ,CAgBuB;AACnB,YAAQ,IAAR,CAAa,IAAb,EAjBJ,CAiBwB;AACvB;AACD;;;;AAIA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,aACkB,EAAC,GAAG,SAAJ,EADlB;AAAA,kBACS,CADT;AAAA,QACS,CADT,wBACa,CADb;;AAEI,YAAQ,IAAR,CAAa,CAAb,EAFJ,CAEoB;;AAFpB,cAIkB,EAAC,GAAG,IAAJ,EAJlB;AAAA,oBAIS,CAJT;AAAA,QAIS,CAJT,yBAIa,CAJb;;AAKI,YAAQ,IAAR,CAAa,CAAb,EALJ,CAKoB;AACnB;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,gBACgB,EAAC,KAAK,KAAN,EADhB;AAAA,QACS,GADT,SACS,GADT;;AAEI,YAAQ,IAAR,CAAa,GAAb,EAFJ,CAEuB;AACtB;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA,CAIC;AAHG;AACA;AACA;;AAEJ;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AAAA,8BAEU,CAAC,IAAD,EAAO,KAAP,CAFV;AACI;;;AADJ,eAGU,KAHV;;AAAA;;AAAA,8BAIU,EAJV;AAKC;AACD;;;AAGA,QAAQ,GAAR,CAAY,mBAAZ;AACA;AACI;AACA,QAAI,MAAM,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAV;AAFJ,QAGa,KAHb,GAG+C,GAH/C,CAGS,CAHT;AAAA,QAGuC,IAHvC,GAG+C,GAH/C,CAGqB,IAAI,MAAJ,GAAa,CAHlC;;AAII,YAAQ,IAAR,CAAa,KAAb,EAJJ,CAIyB;AACrB,YAAQ,IAAR,CAAa,IAAb,EALJ,CAKwB;AACvB","file":"对象的解构赋值002-compiled.js","sourcesContent":["/**\n * Created by liguohua on 16/10/10.\n */\n/**\n * 解构不仅可以用于数组，还可以用于对象。\n */\nconsole.log(\"**************001\");\n{\n    var {foo, bar} = {foo: \"aaa\", bar: \"bbb\"};\n    console.log(foo);\n    console.log(bar);\n}\n\n\n/**\n *数组的元素是按次序排列的，变量的取值由它的位置决定；\n * 而对象的属性没有次序，变量必须与属性同名，才能取到正确的值\n */\nconsole.log(\"**************002\");\n{\n    var {baz} = {foo: \"aaa\", bar: \"bbb\"};\n    console.info(baz);\n}\n\n\n/**\n 如果变量名与属性名不一致，必须写成下面这样\n */\nconsole.log(\"**************003\");\n{\n    var {foo: baz} = {foo: 'aaa', bar: 'bbb'};\n    console.info(baz); // \"aaa\"\n}\n\n\n/**\n *对象的解构赋值是下面形式的简写\n */\nconsole.log(\"**************004\");\n{\n    var {foo: foo, bar: bar} = {foo: \"aaa\", bar: \"bbb\"};\n    console.info(foo); // \"aaa\"\n\n}\n/**\n *对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n * 实验中两者都可以赋值成功!\n */\nconsole.log(\"**************005\");\n{\n    var {foo: baz} = {foo: \"aaa\", bar: \"bbb\"};\n    console.info(baz); // \"aaa\"\n    console.info(foo); // \"aaa\"\n}\n/**\n *采用这种写法时，变量的声明和赋值是一体的。\n * 对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。\n\n\n */\nconsole.log(\"**************006\");\n{\n    let foo;\n    // let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration \"foo\"\n    //\n    // let baz;\n    // let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration \"baz\"\n}\n/**\n *let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。\n */\nconsole.log(\"**************007\");\n{\n    let foo;\n    (\n        {foo} = {foo: 1},\n            console.info(foo)//1\n    ); // 成功\n    console.info(foo)//1\n\n    let baz;\n    (\n        {bar: baz} = {bar: 1},\n            console.info(baz)//1\n    ); // 成功\n    console.info(baz)//1\n\n}\n/**\n *数组一样，解构也可以用于嵌套结构的对象。\n */\nconsole.log(\"**************008\");\n{\n    var obj = {\n        p: [\n            'Hello',\n            {y: 'World'}\n        ]\n    };\n    // 这时p是模式，不是变量，因此不会被赋值\n    var {p: [x, {y}]} = obj;\n    console.info(x);// \"Hello\"\n    console.info(y);// \"World\"\n}\n/**\n *只有line是变量，loc和start都是模式，不会被赋值。\n */\nconsole.log(\"**************009\");\n{\n    var node = {\n        loc: {\n            start: {\n                line: 1,\n                column: 5\n            }\n        }\n    };\n\n    var {loc: {start: {line}}} = node;\n    console.info(line);// 1\n    // console.info(loc);  // error: loc is undefined\n    // console.info(start); // error: start is undefined\n}\n/**\n *嵌套赋值的例子。\n */\nconsole.log(\"**************010\");\n{\n    let obj = {};\n    let arr = [];\n\n    (\n        {\n            foo: obj.prop,\n            bar: arr[0]\n        }\n            =\n        {\n            foo: 123,\n            bar: true\n        }\n    );\n\n    console.info(obj); // {prop:123}\n    console.info(arr);  // [true]\n}\n/**\n *象的解构也可以指定默认值。\n * 默认值生效的条件是，对象的属性值严格等于undefined。\n */\nconsole.log(\"**************011\");\n{\n    var {x = 3} = {x: undefined};\n    console.info(x);// 3\n\n    var {x = 3} = {x: null};\n    console.info(x);// null\n}\n/**\n *如果解构失败，变量的值等于undefined。\n */\nconsole.log(\"**************012\");\n{\n    var {foo} = {bar: 'baz'};\n    console.info(foo); // undefined\n}\n/**\n *果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n */\nconsole.log(\"**************013\");\n{\n    // 报错\n    // var {foo: {bar}} = {baz: 'baz'};\n    //等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错\n}\n/**\n *解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。\n */\nconsole.log(\"**************014\");\n{\n    //上面的表达式虽然毫无意义，但是语法是合法的，可以执行。\n    ({} = [true, false]);\n    ({} = 'abc');\n    ({} = []);\n}\n/**\n *由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n */\nconsole.log(\"**************015\");\n{\n    //数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”\n    var arr = [1, 2, 3];\n    var {0 : first, [arr.length - 1] : last} = arr;\n    console.info(first); // 1\n    console.info(last); // 3\n}\n"]}