{"version":3,"sources":["数组的解构赋值001.js"],"names":[],"mappings":"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","file":"数组的解构赋值001-compiled.js","sourcesContent":["/**\n * Created by liguohua on 16/10/10.\n */\n\n/**\n * 以前，为变量赋值，只能直接指定值。\n */\nconsole.info(\"******************test001\");\nfunction test001() {\n    var a = 1;\n    var b = 2;\n    var c = 3;\n    console.info(a + b + c);\n}\ntest001();\n\n\n/**\n ES6允许写成下面这样。\n 按照对应位置，对变量赋值\n */\nconsole.info(\"******************test002\");\nfunction test002() {\n    var [a, b, c] = [1, 2, 3];\n    console.info(a + b + c);\n}\ntest002();\n\n\n/**\n 解构不成功，变量的值就等于undefined\n */\nconsole.info(\"******************test003\");\nfunction test003() {\n    let [foo, [[bar], baz]] = [1, [[2], 3]];\n    console.info(foo);// 1\n    console.info(bar);// 2\n    console.info(baz);// 3\n\n    let [ , , third] = [\"foo\", \"bar\", \"baz\"];\n    console.info(third); // \"baz\"\n\n    let [x, , y] = [1, 2, 3];\n    console.info(x); // 1\n    console.info(y); // 3\n\n    let [head, ...tail] = [1, 2, 3, 4];\n    console.info(head);  // 1\n    console.info(tail);  // [2, 3, 4]\n\n    let [x0, y0, ...z0] = ['a'];\n    console.info(x0);   // \"a\"\n    console.info(y0);   // undefined\n    console.info(z0);   // []\n}\ntest003();\n\n\n/**\n 解构不成功，变量的值就等于undefined\n */\nconsole.info(\"******************test004\");\nfunction test004() {\n    var [foo] = [];\n    console.info(foo);\n    var [bar, foo] = [1];\n    console.info(foo);\n\n}\ntest004();\n\n\n/**\n 不完全解\n 即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n */\nconsole.info(\"******************test005\");\nfunction test005() {\n    let [x, y] = [1, 2, 3];\n    console.info(x);// 1\n    console.info(y);// 2\n\n    let [a, [b], d] = [1, [2, 3], 4];\n    console.info(a);// 1\n    console.info(b);// 2\n    console.info(d);// 4\n}\ntest005();\n\n\n/**\n * 报错\n 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。\n */\nconsole.info(\"******************test006\");\nfunction test006() {\n    // 报错\n    var [foo] = 1;\n    var [foo] = false;\n    var [foo] = NaN;\n    var [foo] = undefined;\n    var [foo] = null;\n    var [foo] = {};\n}\n// test006();\n\n/**\n * 解构赋值不仅适用于var命令，也适用于let和const命令。\n * 对于Set结构，也可以使用数组的解构赋值。\n * 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。\n * fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。\n */\nconsole.info(\"******************fibs\");\nfunction* fibs() {\n    var a = 0;\n    var b = 1;\n    while (true) {\n        yield a;\n        [a, b] = [b, a + b];\n    }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nconsole.log(first);// 0\nconsole.log(second);// 1\nconsole.log(third);// 1\nconsole.log(fourth);// 2\nconsole.log(fifth);// 3\nconsole.log(sixth);// 5\n\n\n/**\n 默认值\n 解构赋值允许指定默认值。\n */\nconsole.info(\"******************test007\");\nfunction test007() {\n    var [foo = true] = [];\n    console.info(foo);// true\n    //ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的.\n    // null不严格等于undefined\n    //默认值不生效\n    var [x = 1] = [null];\n    console.info(x);// null\n    //默认值生效\n    var [x = 1] = [undefined];\n    console.info(x);// 1\n}\ntest007();\n\n/**\n 默认值\n 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。。\n */\n{\n    console.info(\"******************\");\n    function f() {\n        console.log('aaa');\n    }\n\n    let [x = f()] = [1];\n}\n\n/**\n * 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n */\n{\n    // let [x = 1, y = x] = [];     // x=1; y=1\n    // let [x = 1, y = x] = [2];    // x=2; y=2\n    // let [x = 1, y = x] = [1, 2]; // x=1; y=2\n    // let [x = y, y = 1] = [];     // ReferenceError\n}"]}